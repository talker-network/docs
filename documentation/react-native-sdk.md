# React Native SDK

\*\*React Native sdk  to be deployed on npm soon .\*\*

## Installation

1.  **Install the SDK:**



    ```typescript
    npm install @talker/react-native-sdk
    ```

    Use code with caution
2.  **Configure Firebase:**

    * Add your Firebase project's `google-services.json` file to your React Native project's `android/app` directory.
    * Follow Firebase's instructions to set up the iOS configuration in your Xcode project.
    * Submit the google-services.json and google-services-info.plist file to Talker for firebase cloud messaging compatibility.



***

## Usage

### **Initialization**

```typescript
import Talker from '@talker/react-native-sdk';

// Initialize the Talker SDK
Talker.initialize('YOUR_SDK_KEY');
```



### User Management

#### **User Class**

* **Properties:**
  * `userId`: A unique identifier for the user.
  * `name`: The user's display name.



**Why create or set a user in the sdk?**

* To establish a unique identity within the Talker system.
* To associate your application with specific user data.
* To enable communication between different users using channels.



**Creating a User**

**When a new user has to be created in talker system and associated with  your application ,**&#x20;

* **Call the `createUser` method:**

```typescript
Talker.createUser({
    name: 'username1',
    fcmToken: 'your_fcm_token'
.then(user => {
    console.log('User created:', user);
})
.catch(error => {
    console.error('Error creating user:', error);
});
```



#### **Setting a User**

**When an already existing user in talker system has to be associated with your application,**

* **Call the `setUser` method:**

```typescript
Talker.setUser({
    userId: 'userId',
    fcmToken: 'fcm token generated by you',
    
})
.then(user => {
    console.log('User updated:', user);
})
.catch(error => {
    console.error('Error updating user:', error);
});
```



#### **To get list of  all users  created in the system**

* **Call the `getAllUsers` method**

```typescript
Talker.getAllUsers()
.then(users => {
    console.log('All users:', users);
})
.catch(error => {
    console.error('Error getting all users:', error);
});
```



#### **Current User Object**

The Talker SDK provides a `Talker.currentUser` property that represents the currently associated user in the application. This object holds information about the user's ID, name.



#### **Event Listeners for User Updates**

To provide real-time feedback on user updates, you can use the Talker SDK's event listeners:

* **`onNewUser`**: Triggered when a new user is created in the sdk .



```typescript


Talker.broadcastListener.on('onNewUser').listen(user) => {
    console.log('New user created in the sdk :', user);
});


```



### Channel Management

#### **Channel Class**

* **Properties:**
  * `channelId`: A unique identifier for the channel.
  * `name`: The channel's name.
  * `participants`: An array of channel participants.
  * `type` :  group or direct&#x20;

#### **Channel Participant Class**

* **Properties:**
  * `userId`: The ID of the participant.
  * `name` : The name of the participant
  * `admin`: boolean representing whether the participant is admin of the channel or not.

#### Admin of a Group channel&#x20;

**Admin:** Admins have the highest level of permissions and can perform all actions within a channel, including:

* Adding and removing participants
* Assigning and revoking admin status of other participants
* Deleting a channel.

#### **Creating a Group Channel**

* **Call the `createGroupChannel` method:**&#x54;ypeScript

```typescript
Talker.createGroupChannel({
    name: 'Group Channel 1',
    participantIds: ['user1_id', 'user2_id'],
})
.then(channel => {
    console.log('Group channel created:', channel);
})
.catch(error => {
    console.error('Error creating group channel:', error);
})
```

**The currently associated user who creates the group is always automaticlly included in participantIds and is the admin of the group created.**



#### **Creating a Direct Channel**

* **Call the `createDirectChannel` method:**

```typescript
Talker.createDirectChannel({
    participantId:'user_id',
})
.then(channel => {
    console.log('Direct channel created:', channel);
})
.catch(error => {
    console.error('Error creating direct channel:', error);
});
```



#### To get list of all channels that the current user is part of ,

* call getChannelList method :

```typescript
Talker.getChannelList()
.then(channels => {
    console.log('List of channel class objects', channels);
})
.catch(error => {
    console.error('Error fetching the list :', error);
});

```



**Updating a Group Channel Name**

*   **Call the `updateChannelName` method:**

    ```typescript
    Talker.updateChannelName({
        channelId: 'channel1',
        name: 'New Channel Name',
    })
    .then(channel => {
        console.log('Channel updated:', channel);
    })
    .catch(error => {
        console.error('Error updating channel:', error);
    });
    ```

    Use code with caution.

#### **Adding a Participant to a  Group Channel**

*   **Call the `addParticipantToChannel` method:**

    ```typescript
    Talker.addParticipantToChannel({
        channelId: 'channel1',
        participantId:'userId1',
    })
    .then(channel => {
        console.log('Participant added to channel:', channel);
    })
    .catch(error => {
        console.error('Error adding participant to channel:', error);
    });
    ```

    Use code with caution.

#### **Removing a Participant from a Group Channel**

*   **Call the `removeParticipantFromChannel` method:**

    ```typescript
    Talker.removeParticipantFromChannel({
        channelId: 'channel1',
        userId: 'userId1',
    })
    .then(channel => {
        console.log('Participant removed from channel:', channel);
    })
    .catch(error => {
        console.error('Error removing participant from channel:', error);
    });
    ```

    Use code with caution.



#### **To  assign admin status to a  participant  of  a group channel**&#x20;

*   **Call the `setChannelAdmin` method:**

    ```typescript
    talker.setChannelAdmin({
        channelId: 'channel1',
        participantId: 'user3',
    })
    .then(channel => {
        console.log('Participant assigned with the admin status:', channel);
    })
    .catch(error => {
        console.error('Error assigning admin status:', error);
    });
    ```





#### To revoke admin status of a participant in group channel

*   **Call the `revokeAdminStatus` method:**

    ```typescript
    talker.revokeAdminStatus({
        channelId: 'channel1',
        participantId: 'user3',
    })
    .then(channel => {
        console.log('Participant"s admin status revoked in the channel:', channel);
    })
    .catch(error => {
        console.error('Error revoking admin status:', error);
    });
    ```

    Use code with caution.

#### To delete a channel

*   **Call the `deleteChannel`method:**

    ```typescript
    Talker.deleteChannel({
        channelId: 'channel1',
       
    })
    .then(result => {
        console.log('Channel deleted successfully:', result);
    })
    .catch(error => {
        console.error('Error deleting channel:', error);
    });
    ```

    Use code with caution.

#### To leave a channel

*   **Call the `leaveChannel`method:**

    ```typescript
    Talker.leaveChannel({
        channelId: 'channel1',
       
    })
    .then(result => {
        console.log('Channel left successfully:', result);
    })
    .catch(error => {
        console.error('Error leaving channel:', error);
    });
    ```

    Use code with caution.

#### **Event Listeners for Channel Updates**

To provide real-time feedback on  updates for the **channels that the current user is part of** , you can use the Talker SDK's event listeners:

* **`onNewChannel`**: Triggered when the current user has been added to a channel.
* **`onChannelNameUpdated`** : Triggered when the channel name has been changed.
* **`onChannelParticipantAdded`**: Triggered when a new participant is added to a channel
* **`onChannelParticipantRemoved`**: Triggered when a user has been removed from a channel&#x20;
* **`onChannelRemoved`**: Triggered when a channel  is deleted or the current user is removed from the channel
* **`onChannelAdminChanged`**: Triggered when the channel's admin changes.



```typescript
Talker.broadcastListener.on('onNewChannel').listen(channel) => {
     console.log('New channel created:', channel);
});


Talker.broadcastListener.on('onChannelNameUpdated').listen(channel) => {
   console.log('Channel name updated:', channel);
});

Talker.broadcastListener.on('onChannelRemoved').listen(data) => {
     console.log('Channel removed:', data);
     //data -> {'channelId':String}
 });


Talker.broadcastListener.on('onChannelParticipantAdded').listen(data) => {
    console.log('New participant in channel :', data);
    //data -> {'channelId':String,'userId':String,'name':String,'admin':bool}
});

Talker.broadcastListener.on('onChannelParticipantRemoved').listen(data) => {
    console.log('User removed from channel:', data);
    //data -> {'channelId':String,'userId':String}
});


Talker.broadcastListener.on('onChannelAdminCha').listen(data) => {
      console.log('Channel admin changed:',data);
      //data -> {'channelId':String,'userId':String,'admin':bool}
});


```



### &#x20;Push-to-Talk Functionality

#### Sending PTT Audio



**To start transmitting PTT audio ,**

* Call startPttAudio method:

```typescript
Talker.startPttAudio(channelId:"channelId");
```

`channelId` parameter in the method above is optional , if it is not passed in the above method , the sdk assumes the public channel which is named general.



#### To stop transmitting PTT audio ,

* call stopPttAudio method:

```typescript
Talker.stopPttAudio();
```



#### To provide real-time feedback on the status of PTT audio transmission, you can use the Talker SDK's event listener `PttAudioTransmissionStatus`:

```typescript
Talker.broadcastListener.on('PttAudioTransmissionStatus').listen(event)=>{

console.log(event.name);
});
```

It includes multiple event types that indicate different stages of the PTT Audio transmission process:

**1. `CONNECTING`:** This event is triggered when the PTT audio transmission is starting to connect. It indicates that the SDK is checking or establishing a connection to the server to initiate the PTT audio transmission

**2. `SENDING`:** This event is triggered when the PTT audio is being sent. It signifies that the recorded audio is being transmitted to the server for broadcasting to other participants in the channel.

**3. `STOPPED`:** This event is triggered when the PTT audio transmission has stopped. It indicates that the user has released the PTT button or that the transmission has been terminated for other reasons.

**4. `BUSY`:** This event is triggered when the channel is already busy because another participant is already transmitting audio in that channel. It signifies that there is already an ongoing PTT session in the channel, and the user's PTT request has been rejected.



#### Receiving Audio

The sdk automatically starts playing ptt audio when a channel that the  current user is part of is receiving ptt audio broadcast .

An event Listener C`urrentPttAudio`  provides real-time updates about the metadata for the ptt audio that is being currently played in the application.

<pre class="language-typescript"><code class="lang-typescript">Talker.broadcastListener.on("CurrentPttAudio").listen((event)=>{
console.log(event);

/*
        event ->{
<strong>                “sender_id” : String,
</strong>
                “channel_id” : String,

                “channel_name” : String,

                “sender_name” : String
                }

*/
});
</code></pre>

A foreground service is always running that is responsible for playing the Ptt Audio . A notification in system tray is there to depict that the foreground service is running .

* The notification content changes according to current  ptt audio being played by the application. The title of the notification becomes the channel name in which the current ptt audio is  being broadcasted in .The body of notification changes to the name of the sender of ptt audio.
* The foreground service helps playing audio even if the app is in foreground or killed.



#### **Sending FCM Messages:**

&#x20;Talker SDK sends  FCM messages to the recipient's device if its not connected to talker servers, containing the necessary information about the PTT audio.

**Handling FCM Messages in Your App:**

* Implement a listener to handle incoming FCM messages in your React Native app.
* When you receive an FCM message related to a Talker SDK PTT audio, call the `Talker.handleFcm(data)` function with the FCM message data as a parameter.

**`Talker.handleFcm(data)` Function:**

This function is responsible for processing the FCM message and triggering the appropriate actions within the Talker SDK .

**Its important to handle fcm messages sent by talker sdk to get the appropriate push-to-talk functionality**
